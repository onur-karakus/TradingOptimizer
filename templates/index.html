<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradingOptimizer Pro - Gelişmiş Finansal Analiz</title>
    
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Charting Library -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    
    <style>
        :root {
            --bg-primary: #131722;
            --bg-secondary: #1e222d;
            --bg-tertiary: #2a2e39;
            --text-primary: #d1d4dc;
            --text-secondary: #8c919e;
            --accent-primary: #2962ff;
            --accent-secondary: #e91e63;
            --border-color: #2a2e39;
            --up-color: #089981;
            --down-color: #f23645;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .main-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* --- Sol Araç Çubuğu --- */
        .left-toolbar {
            width: 50px;
            flex-shrink: 0;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .tool-btn {
            background: none; border: none;
            color: var(--text-secondary); cursor: pointer;
            padding: 8px; border-radius: 4px;
            transition: all 0.2s ease;
        }
        .tool-btn:hover, .tool-btn.active {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .tool-separator {
            width: 60%;
            height: 1px;
            background-color: var(--border-color);
            margin: 5px 0;
        }

        /* --- Orta Grafik Alanı --- */
        .center-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        /* --- Sağ Bilgi Paneli --- */
        .right-sidebar {
            width: 300px;
            flex-shrink: 0;
            background-color: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.1rem;
            font-weight: 600;
        }
        .watchlist-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        .watchlist-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid var(--border-color);
        }
        .watchlist-item:hover { background-color: var(--bg-tertiary); }
        .watchlist-item .pair { font-weight: 500; }
        .watchlist-item .price { text-align: right; }
        .watchlist-item .change { font-size: 0.8rem; }
        
        /* --- Grafik Alanı Detayları --- */
        #chart-container {
            position: relative; flex-grow: 1;
            display: flex; flex-direction: column;
        }
        #chart-toolbar {
            display: flex; align-items: center; gap: 12px;
            padding: 5px 10px; flex-shrink: 0;
            flex-wrap: wrap;
        }
        #pair-info h1 { font-size: 1.2rem; font-weight: 600; cursor: pointer;}
        .indicators-btn, .interval-btn {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 12px; border-radius: 6px;
            background-color: transparent;
            border: none;
            color: var(--text-secondary); cursor: pointer;
            transition: all 0.2s ease;
        }
        .indicators-btn:hover, .interval-btn:hover, .interval-btn.active { 
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        #active-indicators-list {
            display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
            margin-left: 10px;
        }
        .indicator-tag {
            display: flex; align-items: center; gap: 6px;
            background-color: var(--bg-tertiary); padding: 4px 8px;
            border-radius: 4px; font-size: 0.8rem;
        }
        .indicator-tag .config-indicator-btn,
        .indicator-tag .remove-indicator-btn {
            background: none; border: none; color: var(--text-secondary);
            cursor: pointer; display: flex; transition: color 0.2s;
        }
        .indicator-tag .config-indicator-btn:hover { color: var(--accent-primary); }
        .indicator-tag .remove-indicator-btn:hover { color: var(--accent-secondary); }

        #main-chart { flex-grow: 1; min-height: 250px; }
        #secondary-chart-container { 
            flex-shrink: 0; height: 30%;
        }
        #secondary-chart-container.hidden { display: none; }
        
        #loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border: 6px solid var(--bg-tertiary);
            border-top: 6px solid var(--accent-primary);
            border-radius: 50%; width: 50px; height: 50px;
            animation: spin 1s linear infinite;
            z-index: 10; display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Modal Stilleri */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none; justify-content: center; align-items: flex-start;
            padding-top: 10vh;
            z-index: 1001;
        }
        .modal-content {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 90%; max-width: 500px;
            max-height: 80vh;
            display: flex; flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 16px 20px; border-bottom: 1px solid var(--border-color);
        }
        .modal-header h4 { font-size: 1.1rem; }
        .close-modal-btn { background: none; border: none; color: var(--text-secondary); cursor: pointer; }
        .modal-body { padding: 20px; overflow-y: auto; }
        .modal-body input {
            width: 100%; padding: 12px;
            margin-bottom: 20px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary); border-radius: 6px;
        }
        #indicators-list, #symbols-list { list-style: none; padding: 0;}
        .list-item {
            padding: 12px 8px;
            border-radius: 6px; cursor: pointer;
            transition: background-color 0.2s;
        }
        .list-item:hover { background-color: var(--bg-tertiary); }
        .list-item h5 { font-size: 1rem; margin-bottom: 4px; display: flex; align-items: center;}
        .list-item p { font-size: 0.8rem; color: var(--text-secondary); }
        .list-item span.type-tag {
            font-size: 0.7rem; padding: 2px 6px;
            border-radius: 4px; margin-left: 8px;
        }
        .type-tag.overlay { background-color: var(--accent-primary); color: white; }
        .type-tag.pane { background-color: var(--accent-secondary); color: white; }
        
        #settings-form .form-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #settings-form label { font-size: 0.9rem; }
        #settings-form input[type="number"] {
            width: 80px; padding: 8px;
            background-color: var(--bg-tertiary); border: 1px solid var(--border-color);
            color: var(--text-primary); border-radius: 4px;
        }
        .modal-footer {
            padding: 16px 20px; border-top: 1px solid var(--border-color);
            display: flex; justify-content: flex-end; gap: 10px;
        }
        .modal-footer button {
            padding: 8px 16px; border-radius: 6px; border: none;
            cursor: pointer; font-weight: 500;
        }
        .btn-primary { background-color: var(--accent-primary); color: white; }
        .btn-secondary { background-color: var(--bg-tertiary); color: var(--text-primary); }
    </style>
</head>
<body>

    <div class="main-container">
        <aside class="left-toolbar">
            <button class="tool-btn active"><i data-lucide="move-diagonal"></i></button>
            <div class="tool-separator"></div>
            <button class="tool-btn"><i data-lucide="trending-up"></i></button>
        </aside>

        <div class="center-content">
            <div id="chart-toolbar">
                <div id="pair-info"></div>
                <div class="interval-buttons-container"></div>
                <div class="toolbar-separator"></div>
                <button class="indicators-btn" id="open-indicator-modal-btn">
                    <i data-lucide="bar-chart-horizontal"></i>
                    <span>Göstergeler</span>
                </button>
                <div id="active-indicators-list"></div>
            </div>
            <div id="chart-container">
                <div id="loader"></div>
                <div id="main-chart"></div>
                <div id="secondary-chart-container" class="hidden"></div>
            </div>
        </div>

        <aside class="right-sidebar">
            <div class="sidebar-header">İzleme Listesi</div>
            <div class="watchlist-container"></div>
        </aside>
    </div>
    
    <div id="indicator-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h4>Göstergeler</h4><button class="close-modal-btn"><i data-lucide="x"></i></button></div>
            <div class="modal-body">
                <input type="text" id="indicator-search" placeholder="Gösterge ara..."><ul id="indicators-list"></ul>
            </div>
        </div>
    </div>
    <div id="symbol-search-overlay" class="modal-overlay">
         <div class="modal-content">
            <div class="modal-header"><h4>Sembol Ara</h4><button class="close-modal-btn"><i data-lucide="x"></i></button></div>
            <div class="modal-body">
                <input type="text" id="symbol-search-input" placeholder="Sembol ara (örn: ETHUSDT)"><ul id="symbols-list"></ul>
            </div>
        </div>
    </div>
     <div id="settings-modal-overlay" class="modal-overlay">
         <div class="modal-content">
            <div class="modal-header"><h4 id="settings-modal-title">Ayarlar</h4><button class="close-modal-btn"><i data-lucide="x"></i></button></div>
            <div class="modal-body"><form id="settings-form"></form></div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary close-modal-btn">İptal</button>
                <button type="submit" form="settings-form" class="btn-primary">Uygula</button>
            </div>
        </div>
    </div>
    <div id="toast"></div>

    <script>
    document.addEventListener("DOMContentLoaded", () => {
        const loader = document.getElementById('loader');
        const pairInfoEl = document.getElementById('pair-info');
        const mainChartEl = document.getElementById('main-chart');
        const secondaryChartEl = document.getElementById('secondary-chart-container');
        
        let mainChart, secondaryChart;
        let currentInterval = '1h', currentSymbol = 'BTCUSDT';
        let rawKlineData = [], activeOverlays = [], activePaneIndicator = null;

        // HATA DÜZELTME: Tüm indikatörler listeye eklendi.
        const indicators = [
            { id: 'ema', name: 'Üstel Hareketli Ortalama', type: 'overlay', calculation: calculateEMA, settings: [{ id: 'period', name: 'Uzunluk', type: 'number', default: 20 }] },
            { id: 'bb', name: 'Bollinger Bantları', type: 'overlay', calculation: calculateBollingerBands, settings: [{ id: 'period', name: 'Uzunluk', type: 'number', default: 20 }, { id: 'stdDev', name: 'StdSapma', type: 'number', default: 2 }] },
            { id: 'ichimoku', name: 'Ichimoku Bulutu', type: 'overlay', calculation: calculateIchimoku, settings: [ {id: 'tenkanP', name: 'Tenkan', type: 'number', default: 9}, {id: 'kijunP', name: 'Kijun', type: 'number', default: 26}, {id: 'senkouBP', name: 'Senkou B', type: 'number', default: 52}] },
            { id: 'rsi', name: 'Göreceli Güç Endeksi', type: 'pane', calculation: calculateRSI, settings: [{ id: 'period', name: 'Uzunluk', type: 'number', default: 14 }] },
            { id: 'macd', name: 'MACD', type: 'pane', calculation: calculateMACD, settings: [ { id: 'fast', name: 'Hızlı Uzunluk', type: 'number', default: 12 }, { id: 'slow', name: 'Yavaş Uzunluk', type: 'number', default: 26 }, { id: 'signal', name: 'Sinyal Düzeltme', type: 'number', default: 9 }] },
            { id: 'stochastic', name: 'Stokastik Osilatör', type: 'pane', calculation: calculateStochastic, settings: [{id: 'kPeriod', name: '%K Periyodu', type: 'number', default: 14}, {id: 'dPeriod', name: '%D Periyodu', type: 'number', default: 3}] },
            { id: 'atr', name: 'Ortalama Gerçek Aralık', type: 'pane', calculation: calculateATR, settings: [{id: 'period', name: 'Uzunluk', type: 'number', default: 14}] },
            { id: 'adx', name: 'Ortalama Yönsel Endeks', type: 'pane', calculation: calculateADX, settings: [{id: 'period', name: 'Uzunluk', type: 'number', default: 14}] },
            { id: 'volume', name: 'İşlem Hacmi', type: 'pane', calculation: (d) => [{ name: 'Hacim', type: 'bar', data: d.map((p, i) => ({ x: p.x, y: p.v, fillColor: i > 0 && d[i].c >= d[i-1].c ? 'var(--up-color)' : 'var(--down-color)' })) }] },
        ];
        const availableSymbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'DOGEUSDT'];

        const mainChartOptions = {
            series: [], chart: { type: 'candlestick', height: '100%', id: 'mainChart', group: 'tradingCharts', background: 'transparent', toolbar: { show: true, tools: { download: false, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } }, zoom: { enabled: true, type: 'x', autoScaleYaxis: true } },
            xaxis: { type: 'datetime', labels: { style: { colors: 'var(--text-secondary)'} } },
            yaxis: { tooltip: { enabled: true }, labels: { style: { colors: 'var(--text-secondary)'}, formatter: (v) => v ? `$${v.toFixed(2)}` : '' }, opposite: true },
            tooltip: { shared: true, theme: 'dark', x: { format: 'dd MMM HH:mm' } },
            plotOptions: { candlestick: { colors: { upward: 'var(--up-color)', downward: 'var(--down-color)' }, wick: { useFillColor: true } } },
            grid: { borderColor: 'var(--border-color)', strokeDashArray: 4 },
        };
        const secondaryChartOptions = {
            series: [], chart: { type: 'line', height: '100%', id: 'secondaryChart', group: 'tradingCharts', background: 'transparent', toolbar: { show: false } },
            xaxis: { type: 'datetime', labels: { show: false } },
            yaxis: { labels: { style: { colors: 'var(--text-secondary)' } }, opposite: true },
            tooltip: { theme: 'dark', x: { format: 'dd MMM HH:mm' } },
            grid: { borderColor: 'var(--border-color)', strokeDashArray: 4 }
        };

        function init() {
            lucide.createIcons();
            mainChart = new ApexCharts(mainChartEl, mainChartOptions);
            secondaryChart = new ApexCharts(document.querySelector("#secondary-chart-container"), secondaryChartOptions);
            mainChart.render(); secondaryChart.render();
            
            populateIndicatorModal(); populateSymbolModal(); createTimeIntervalButtons();
            
            setupEventListeners();
            fetchDataAndRender(currentSymbol, currentInterval);
        }

        function setupEventListeners() {
            document.getElementById('open-indicator-modal-btn').addEventListener('click', () => showModal('indicator-modal-overlay'));
            pairInfoEl.addEventListener('click', () => showModal('symbol-search-overlay'));
            
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                overlay.addEventListener('click', e => { if(e.target === overlay) hideModal(overlay.id); });
                overlay.querySelector('.close-modal-btn').addEventListener('click', () => hideModal(overlay.id));
            });
            document.getElementById('settings-form').addEventListener('submit', handleSettingsSave);

            document.getElementById('indicator-search').addEventListener('keyup', e => filterList(e.target.value, '#indicators-list'));
            document.getElementById('symbol-search-input').addEventListener('keyup', e => filterList(e.target.value, '#symbols-list'));
        }
        
        async function fetchDataAndRender(symbol, interval) {
            loader.style.display = 'block';
            try {
                const url = new URL('/api/data', window.location.origin);
                url.searchParams.set('symbol', symbol);
                url.searchParams.set('interval', interval);
                const response = await fetch(url.toString());
                if (!response.ok) throw new Error(`API Hatası: ${response.status}`);
                rawKlineData = await response.json();
                if (rawKlineData && rawKlineData.length > 0) {
                    updateAllIndicators(); updatePriceHeader();
                } else {
                   mainChart.updateOptions({ series: [] }); secondaryChart.updateOptions({ series: [] });
                }
            } catch (error) { console.error("Veri çekme hatası:", error);
            } finally { loader.style.display = 'none'; }
        }
        
        function updateAllIndicators() {
            if (!rawKlineData || rawKlineData.length === 0) return;
            const data = parseData(rawKlineData);
            updateMainChartSeries(data);
            updateSecondaryChartSeries(data);
            updateActiveIndicatorTags();
        }
        
        function updateMainChartSeries(data) {
            let mainSeries = [{ type: 'candlestick', name: 'Fiyat', data: data.map(d => ({ x: d.x, y: [d.o, d.h, d.l, d.c] })) }];
            activeOverlays.forEach(indicator => {
                const indicatorData = indicator.definition.calculation(data, indicator.settings);
                if (!indicatorData || !Array.isArray(indicatorData)) return;
                indicatorData.forEach(seriesObject => {
                    if (seriesObject && seriesObject.hasOwnProperty('data')) {
                        mainSeries.push(seriesObject);
                    }
                });
            });
            mainChart.updateOptions({ series: mainSeries });
        }

        function updateSecondaryChartSeries(data) {
            if (activePaneIndicator) {
                secondaryChartEl.classList.remove('hidden');
                
                const seriesData = activePaneIndicator.definition.calculation(data, activePaneIndicator.settings);
                const secondarySeries = Array.isArray(seriesData) ? seriesData : [];
                
                let opts = { series: secondarySeries, yaxis: { labels: { style: { colors: 'var(--text-secondary)'}}, opposite: true }, chart: {type: 'line'} };
                if (activePaneIndicator.definition.id === 'rsi' || activePaneIndicator.definition.id === 'stochastic') {
                    opts.yaxis.min = 0; opts.yaxis.max = 100;
                } else if (activePaneIndicator.definition.id === 'volume') {
                    opts.chart.type = 'bar';
                }
                secondaryChart.updateOptions(opts);
            } else {
                secondaryChartEl.classList.add('hidden');
                secondaryChart.updateOptions({ series: [] });
            }
        }
        
        function updatePriceHeader() { pairInfoEl.innerHTML = `<h1>${currentSymbol.replace('USDT', '')}/USDT</h1>`; }
        function handleIntervalChange(newInterval) {
            if (currentInterval === newInterval) return;
            currentInterval = newInterval;
            document.querySelectorAll('.interval-buttons-container .interval-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.interval === newInterval));
            fetchDataAndRender(currentSymbol, currentInterval);
        }
        function handleSymbolChange(newSymbol) {
            if (!newSymbol || newSymbol === currentSymbol) return;
            currentSymbol = newSymbol;
            fetchDataAndRender(currentSymbol, currentInterval);
            hideModal('symbol-search-overlay');
        }
        function addIndicator(indicatorId) {
            const definition = indicators.find(i => i.id === indicatorId);
            if (!definition) return;
            const settings = {};
            if (definition.settings) {
                definition.settings.forEach(setting => {
                    settings[setting.id] = setting.default;
                });
            }
            const newIndicator = { instanceId: `${definition.id}_${Date.now()}`, definition: definition, settings: settings };
            if (definition.type === 'overlay') { activeOverlays.push(newIndicator); } 
            else if (definition.type === 'pane') { activePaneIndicator = newIndicator; }
            hideModal('indicator-modal-overlay');
            updateAllIndicators();
        }
        function removeIndicator(instanceId) {
            activeOverlays = activeOverlays.filter(o => o.instanceId !== instanceId);
            if (activePaneIndicator && activePaneIndicator.instanceId === instanceId) {
                activePaneIndicator = null;
            }
            updateAllIndicators();
        }
        function openSettingsModal(instanceId) {
            const indicator = [...activeOverlays, activePaneIndicator].find(i => i && i.instanceId === instanceId);
            if (!indicator || !indicator.definition.settings) return;
            const form = document.getElementById('settings-form');
            form.innerHTML = '';
            form.dataset.instanceId = instanceId;
            document.getElementById('settings-modal-title').textContent = `${indicator.definition.name} Ayarları`;
            indicator.definition.settings.forEach(setting => {
                const row = document.createElement('div');
                row.className = 'form-row';
                const value = indicator.settings[setting.id];
                row.innerHTML = `<label for="setting-${setting.id}">${setting.name}</label><input type="number" id="setting-${setting.id}" name="${setting.id}" value="${value}">`;
                form.appendChild(row);
            });
            showModal('settings-modal-overlay');
        }
        function handleSettingsSave(e) {
            e.preventDefault();
            const form = e.target;
            const instanceId = form.dataset.instanceId;
            const indicator = [...activeOverlays, activePaneIndicator].find(i => i && i.instanceId === instanceId);
            if (!indicator) return;
            const formData = new FormData(form);
            for (let [key, value] of formData.entries()) {
                indicator.settings[key] = Number(value);
            }
            hideModal('settings-modal-overlay');
            updateAllIndicators();
        }
        function updateActiveIndicatorTags() {
            const listEl = document.getElementById('active-indicators-list');
            listEl.innerHTML = '';
            [...activeOverlays, activePaneIndicator].filter(Boolean).forEach(indicator => {
                const tag = document.createElement('div');
                tag.className = 'indicator-tag';
                let settingsHTML = '';
                if(indicator.definition.settings) {
                    settingsHTML = `<button class="config-indicator-btn" data-id="${indicator.instanceId}"><i data-lucide="settings-2" style="width:14px; height: 14px; pointer-events: none;"></i></button>`;
                }
                const settingsText = Object.values(indicator.settings).join(', ');
                tag.innerHTML = `<span>${indicator.definition.name} ${settingsText ? `(${settingsText})` : ''}</span> ${settingsHTML} <button class="remove-indicator-btn" data-id="${indicator.instanceId}"><i data-lucide="x" style="width:14px; height: 14px; pointer-events: none;"></i></button>`;
                listEl.appendChild(tag);
            });
            listEl.querySelectorAll('.remove-indicator-btn').forEach(btn => btn.addEventListener('click', (e) => removeIndicator(e.currentTarget.dataset.id)));
            listEl.querySelectorAll('.config-indicator-btn').forEach(btn => btn.addEventListener('click', (e) => openSettingsModal(e.currentTarget.dataset.id)));
            lucide.createIcons();
        }
        
        // HATA DÜZELTME: Yardımcı fonksiyonlar dolduruldu.
        function showModal(id) { document.getElementById(id).style.display = 'flex'; }
        function hideModal(id) { document.getElementById(id).style.display = 'none'; }
        function showToast(message) {
             const toastEl = document.getElementById('toast');
            toastEl.textContent = message;
            toastEl.classList.add('show');
            setTimeout(() => { toastEl.classList.remove('show'); }, 3000);
        }
        function populateIndicatorModal() {
             const listEl = document.getElementById('indicators-list');
             listEl.innerHTML = '';
            indicators.forEach(ind => {
                const li = document.createElement('li');
                li.className = 'list-item';
                li.dataset.id = ind.id;
                li.innerHTML = `<h5>${ind.name} <span class="type-tag ${ind.type}">${ind.type === 'overlay' ? 'Ana Grafik' : 'Yeni Bölme'}</span></h5><p>${ind.description || ''}</p>`;
                li.addEventListener('click', () => addIndicator(ind.id));
                listEl.appendChild(li);
            });
        }
        function populateSymbolModal() {
             const listEl = document.getElementById('symbols-list');
             const watchlistEl = document.querySelector('.watchlist-container');
             listEl.innerHTML = '';
             watchlistEl.innerHTML = '';
             availableSymbols.forEach(symbol => {
                 const li = document.createElement('li');
                 li.className = 'list-item';
                 li.innerHTML = `<h5>${symbol}</h5>`;
                 li.addEventListener('click', () => handleSymbolChange(symbol));
                 listEl.appendChild(li);

                 const watchItem = document.createElement('div');
                 watchItem.className = 'watchlist-item';
                 watchItem.dataset.symbol = symbol;
                 watchItem.innerHTML = `<span class="pair">${symbol.replace('USDT','/USDT')}</span><div class="price"><span class="last-price">--</span><span class="change up-color">--</span></div>`;
                 watchItem.addEventListener('click', () => handleSymbolChange(symbol));
                 watchlistEl.appendChild(watchItem);
             });
        }
        function createTimeIntervalButtons() {
            const intervals = ['1m', '5m', '15m', '30m', '1h', '4h', '1d'];
            const topContainer = document.querySelector('.interval-buttons-container');
            topContainer.innerHTML = '';
            intervals.forEach(interval => {
                const btn = document.createElement('button');
                btn.className = 'interval-btn';
                btn.dataset.interval = interval;
                btn.textContent = interval.replace('m', 'D').replace('h', 'S').replace('d', 'G');
                if(interval === currentInterval) btn.classList.add('active');
                btn.addEventListener('click', () => handleIntervalChange(interval));
                topContainer.appendChild(btn);
            });
        }
        function filterList(searchTerm, listId) {
             const items = document.querySelectorAll(`${listId} li`);
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(searchTerm.toLowerCase()) ? '' : 'none';
            });
        }

        // --- İNDİKATÖR HESAPLAMA FONKSİYONLARI ---
        function parseData(rawData) { return rawData.map(k => ({ x: k[0], o: parseFloat(k[1]), h: parseFloat(k[2]), l: parseFloat(k[3]), c: parseFloat(k[4]), v: parseFloat(k[5]) })); }
        
        function calculateEMA(data, settings) {
            const { period } = settings;
            let emaData = [];
            const source = data.map(d => d.c); 
            if (source.length < period) return [];
            const multiplier = 2 / (period + 1);
            let sma = source.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for(let i=0; i < period -1; i++) emaData.push({x: data[i].x, y: null});
            emaData.push({ x: data[period - 1].x, y: sma });
            for (let i = period; i < source.length; i++) {
                if(emaData[i - 1].y === null) { emaData.push({ x: data[i].x, y: null }); continue; }
                const ema = (source[i] - emaData[i - 1].y) * multiplier + emaData[i - 1].y;
                emaData.push({ x: data[i].x, y: ema });
            }
            return [{ name: `EMA (${period})`, data: emaData}];
        }

        function calculateBollingerBands(data, settings) {
            const { period, stdDev } = settings;
            let middle = [], upper = [], lower = [];
            if (data.length < period) return [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) { middle.push({x: data[i].x, y: null}); upper.push({x: data[i].x, y: null}); lower.push({x: data[i].x, y: null}); continue; }
                const slice = data.slice(i - period + 1, i + 1).map(d => d.c);
                const mean = slice.reduce((a, b) => a + b, 0) / period;
                const standardDeviation = Math.sqrt(slice.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / period);
                middle.push({ x: data[i].x, y: mean });
                upper.push({ x: data[i].x, y: mean + stdDev * standardDeviation });
                lower.push({ x: data[i].x, y: mean - stdDev * standardDeviation });
            }
            return [ { name: 'BB Üst', data: upper, color: '#aaa'}, { name: 'BB Orta', data: middle, color: '#ccc'}, { name: 'BB Alt', data: lower, color: '#aaa'} ];
        }

        function calculateRSI(data, settings) {
            const { period } = settings;
            if (data.length <= period) return [];
            const rsiData = []; let avgGain = 0; let avgLoss = 0;
            for (let i = 1; i <= period; i++) {
                const change = data[i].c - data[i - 1].c;
                if (change > 0) { avgGain += change; } else { avgLoss += Math.abs(change); }
            }
            avgGain /= period; avgLoss /= period;
            for (let i = 0; i < period; i++) { rsiData.push({ x: data[i].x, y: null }); }
            let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            rsiData.push({ x: data[period].x, y: 100 - (100 / (1 + rs)) });
            for (let i = period + 1; i < data.length; i++) {
                const change = data[i].c - data[i - 1].c;
                let currentGain = change > 0 ? change : 0;
                let currentLoss = change < 0 ? Math.abs(change) : 0;
                avgGain = (avgGain * (period - 1) + currentGain) / period;
                avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
                rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                rsiData.push({ x: data[i].x, y: 100 - (100 / (1 + rs)) });
            }
            return [{ name: `RSI (${period})`, data: rsiData }];
        }

        function calculateMACD(data, settings) {
            const { fast, slow, signal } = settings;
            const emaFastSeries = calculateEMA(data, {period: fast});
            if (!emaFastSeries || emaFastSeries.length === 0) return [];
            const emaFast = emaFastSeries[0].data;
            const emaSlowSeries = calculateEMA(data, {period: slow});
            if (!emaSlowSeries || emaSlowSeries.length === 0) return [];
            const emaSlow = emaSlowSeries[0].data;
            const macdLine = emaSlow.map((d, i) => {
                if (d.y === null || emaFast[i].y === null) return { x: d.x, y: null, c: null };
                return { x: d.x, c: emaFast[i].y - d.y };
            });
            const signalLineData = macdLine.filter(d => d.c !== null);
            if (signalLineData.length < signal) return [];
            const signalLineSeries = calculateEMA(signalLineData, {period: signal});
            if (!signalLineSeries || signalLineSeries.length === 0) return [];
            const signalLine = signalLineSeries[0].data;
            const nulls = Array.from({length: macdLine.length - signalLine.length}, (_, i) => ({x: macdLine[i].x, y:null}));
            const fullSignalLine = [...nulls, ...signalLine];
            const histogram = fullSignalLine.map((d, i) => {
                if (d.y === null || macdLine[i].c === null) return {x: macdLine[i].x, y: null};
                return {x: macdLine[i].x, y: macdLine[i].c - d.y};
            });
            return [
                { name: 'MACD', data: macdLine.map(d=>({x:d.x, y:d.c})) },
                { name: 'Signal', data: fullSignalLine },
                { name: 'Histogram', type: 'bar', data: histogram }
            ];
        }
        
        function calculateStochastic(data, settings) {
            const {kPeriod, dPeriod} = settings;
            let kLine = [];
            for (let i = 0; i < data.length; i++) {
                if (i < kPeriod - 1) { kLine.push({x: data[i].x, y: null}); continue; }
                const slice = data.slice(i - kPeriod + 1, i + 1);
                const low_k = Math.min(...slice.map(d => d.l));
                const high_k = Math.max(...slice.map(d => d.h));
                const kValue = 100 * ((data[i].c - low_k) / (high_k - low_k || 1));
                kLine.push({ x: data[i].x, c: kValue, y: kValue });
            }
            const dLineSeries = calculateEMA(kLine, {period: dPeriod});
            if (!dLineSeries || dLineSeries.length === 0) return [];
            return [ { name: '%K', data: kLine.map(d=>({x:d.x, y:d.y})) }, { name: '%D', data: dLineSeries[0].data } ];
        }

        function calculateIchimoku(data, settings) {
            const { tenkanP, kijunP, senkouBP } = settings;
            const displacement = kijunP;
            let tenkan = [], kijun = [], chikou = [], senkouA_raw = [], senkouB_raw = [];
            const timestamps = data.map(d => d.x);
            const intervalMs = timestamps.length > 1 ? timestamps[1] - timestamps[0] : 60000;
            for (let i = 0; i < data.length; i++) {
                if (i >= tenkanP - 1) { const slice = data.slice(i - tenkanP + 1, i + 1); tenkan.push({ x: data[i].x, y: (Math.max(...slice.map(d => d.h)) + Math.min(...slice.map(d => d.l))) / 2 }); } else { tenkan.push({x:data[i].x, y: null}); }
                if (i >= kijunP - 1) { const slice = data.slice(i - kijunP + 1, i + 1); kijun.push({ x: data[i].x, y: (Math.max(...slice.map(d => d.h)) + Math.min(...slice.map(d => d.l))) / 2 }); } else { kijun.push({x:data[i].x, y: null}); }
                chikou.push({ x: data[i].x, y: i < data.length - displacement ? data[i + displacement].c : null });
            }
            for(let i = 0; i < data.length; i++) {
                if(tenkan[i].y !== null && kijun[i].y !== null) { senkouA_raw.push({x: data[i].x + (displacement * intervalMs), y: (tenkan[i].y + kijun[i].y) / 2}); } else { senkouA_raw.push({x: data[i].x + (displacement * intervalMs), y: null}); }
                if (i >= senkouBP - 1) { const slice = data.slice(i - senkouBP + 1, i + 1); senkouB_raw.push({x: data[i].x + (displacement * intervalMs), y: (Math.max(...slice.map(d => d.h)) + Math.min(...slice.map(d => d.l))) / 2}); } else { senkouB_raw.push({x: data[i].x + (displacement * intervalMs), y: null}); }
            }
            let kumoData = senkouA_raw.map((d, i) => (d.y !== null && senkouB_raw[i]?.y !== null) ? { x: d.x, y: [d.y, senkouB_raw[i].y] } : {x: d.x, y: []});
            const lastA = senkouA_raw.findLast(d => d.y !== null)?.y;
            const lastB = senkouB_raw.findLast(d => d.y !== null)?.y;
            return [
                { name: 'Tenkan Sen', type: 'line', data: tenkan, color: '#03a9f4' },
                { name: 'Kijun Sen', type: 'line', data: kijun, color: '#e91e63' },
                { name: 'Chikou Span', type: 'line', data: chikou, color: '#775dd0' },
                { name: 'Kumo', type: 'rangeArea', data: kumoData, color: lastA > lastB ? 'var(--up-color)' : 'var(--down-color)', fill: { opacity: 0.1 }, stroke: { width: 0 }, zIndex: 0 }
            ];
        }
        
        function calculateATR(data, settings) {
            const { period } = settings;
            let trValues = [ {x: data[0].x, c: null} ];
            if (data.length <= period) return [];
            for (let i = 1; i < data.length; i++) {
                const tr = Math.max(data[i].h - data[i].l, Math.abs(data[i].h - data[i - 1].c), Math.abs(data[i].l - data[i - 1].c));
                trValues.push({x: data[i].x, c: tr});
            }
            const atrResult = calculateEMA(trValues, {period: period});
            return [{ name: `ATR (${period})`, data: atrResult[0].data }];
        }
        
        function calculateADX(data, settings) {
             const { period } = settings;
            if (data.length < period * 2) return [];

            let plusDM = [{x: data[0].x, c: null}];
            let minusDM = [{x: data[0].x, c: null}];

            for (let i = 1; i < data.length; i++) {
                let upMove = data[i].h - data[i-1].h;
                let downMove = data[i-1].l - data[i].l;
                
                plusDM.push({x: data[i].x, c: (upMove > downMove && upMove > 0) ? upMove : 0});
                minusDM.push({x: data[i].x, c: (downMove > upMove && downMove > 0) ? downMove : 0});
            }

            const atrSeries = calculateATR(data, {period});
            if (!atrSeries || atrSeries.length === 0) return [];
            const tr = atrSeries[0].data;
            
            const smoothedPlusDM = calculateEMA(plusDM, {period})[0].data;
            const smoothedMinusDM = calculateEMA(minusDM, {period})[0].data;
            
            let plusDI = [];
            let minusDI = [];
            for (let i = 0; i < data.length; i++) {
                if (smoothedPlusDM[i]?.y && tr[i]?.y) {
                    plusDI.push({x: data[i].x, c: (smoothedPlusDM[i].y / tr[i].y) * 100});
                } else {
                     plusDI.push({x: data[i].x, c: null});
                }
                if (smoothedMinusDM[i]?.y && tr[i]?.y) {
                    minusDI.push({x: data[i].x, c: (smoothedMinusDM[i].y / tr[i].y) * 100});
                } else {
                     minusDI.push({x: data[i].x, c: null});
                }
            }

            let dx = [];
            for (let i = 0; i < data.length; i++) {
                 if (plusDI[i]?.c && minusDI[i]?.c) {
                    const dxVal = (Math.abs(plusDI[i].c - minusDI[i].c) / (plusDI[i].c + minusDI[i].c)) * 100;
                    dx.push({x: data[i].x, c: dxVal});
                } else {
                     dx.push({x: data[i].x, c: null});
                }
            }
            
            const adx = calculateEMA(dx, {period})[0].data;
            return [{name: `ADX (${period})`, data: adx}];
        }
        
        init();
    });
    </script>
</body>
</html>
